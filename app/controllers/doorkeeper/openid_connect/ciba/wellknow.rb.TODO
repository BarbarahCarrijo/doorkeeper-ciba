# frozen_string_literal: true

module Doorkeeper
  module OpenidConnect
  	module Ciba
	    class AuthorizeController < ActionController::API

	  # TODO: configure authentication
		#::Doorkeeper::ApplicationController
	      #before_action -> { doorkeeper_authorize! :openid }
	
	  
	  #unless Doorkeeper.configuration.api_only
	  #  skip_before_action :verify_authenticity_token
	  #end
	  #before_action -> { doorkeeper_authorize! :openid }

	  # TODO: search           token_endpoint_auth_methods_supported: %w[client_secret_basic client_secret_post],

	# Authentication must accept the methods described in https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication
	# from https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0-03.html#auth_request
	#
	# client_secret_basic - http header Auth Bearer w/ ""client_id : client_secret" in base64)
	# client_secret_post - request params client_id + client_secret
	# client_secret_jwt - jwt w/ client_secret signature (HMAC SHA256) / (client_assertion / client_assertion_type)- https://tools.ietf.org/html/rfc7523#section-2.2
	# private_key_jwt - jwt w/ private_key signature (HMAC SHA256) / (client_assertion / client_assertion_type)- https://tools.ietf.org/html/rfc7523#section-2.2
	# tls_client_auth - mutual tls - request params client_id and clientCertificate - https://tools.ietf.org/id/draft-ietf-oauth-mtls-03.html
	# self_signed_tls_client_auth - mutual tls - request params client_id and clientCertificate - https://datatracker.ietf.org/doc/html/rfc8705
	
		  # TODO: error handling

	#  rescue_from ActiveRecord::RecordNotFound do |error|
    #  render json: { errors: [error.message] }, status: 404
    #end

	      def auth

			# All the parameters are described in https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0-03.html#auth_request
			#
			# scope must include openid
			scope = params[:scope].to_s
			
			# required for ping and push mode (used to notify the callback in these modes) - UNSUPPORTED for v1.0
			client_notification_token = params[:client_notification_token].to_s
			
			# optional parameter - authentication context classes - UNSUPPORTED for v1.0
 			acr_values = params[:acr_values].to_s
			
			# Parameters that identify the end-user for whom auth is being requested. At least one must be defined.
			#	
			#As in the CIBA flow the OP does not have an interaction with the end-user through the consumption device, 
			# it is REQUIRED that the Client provides one (and only one) of the hints specified above in the authentication
			# request, that is "login_hint_token", "id_token_hint" or "login_hint".
			#
			if(!(params[:login_hint_token].present? || params[:id_token_hint].present? || params[:login_hint].present?)) 
				 # TODO: check the corret error message
				 render json:  { 
	                      error:  {
	                                message: "Bad Request, parameters missing.",
	                                status: 500
	                              }
	                    }
				return
			end

			# some identification of the user (implementation specific)
			login_hint_token = params[:login_hint_token].to_s
			# id of the user
			id_token_hint = params[:id_token_hint].to_s
			# the value may contain an email address, phone number, account number, subject identifier, username, etc.
			login_hint = params[:login_hint].to_s
			
			# optional - human readable message to be displayed to the users on both consumption and authorization device
			binding_message = params[:binding_message].to_s
			
			# optional - secret client code known only by the user - used to prevent unsolicited authentication requests - UNSUPPORTED for v1.0
			user_code = params[:user_code].to_s
			
			# optional - A positive integer allowing the client to request the expires_in value for the auth_req_id the server will return.
			requested_expiry = params[:requested_expiry].to_s

	        render json: Doorkeeper::OpenidConnect::Ciba::Authorize.new('teste'), status: :ok
	      end
	    end
	end
  end
end









